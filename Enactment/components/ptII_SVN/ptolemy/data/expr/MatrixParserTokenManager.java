/* Generated By:JJTree&JavaCC: Do not edit this line. MatrixParserTokenManager.java */
/* Parser for matrices written in matlab format.

 Copyright (c) 1998-2008 The Regents of the University of California.
 All rights reserved.
 Permission is hereby granted, without written agreement and without
 license or royalty fees, to use, copy, modify, and distribute this
 software and its documentation for any purpose, provided that the above
 copyright notice and the following two paragraphs appear in all copies
 of this software.

 IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
 FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
 THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE.

 THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
 PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
 CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 ENHANCEMENTS, OR MODIFICATIONS.

                                        PT_COPYRIGHT_VERSION_2
                                        COPYRIGHTENDKEY
 */
package ptolemy.data.expr;

/** Token Manager. */
public class MatrixParserTokenManager implements MatrixParserConstants {

    /** Debug output. */
    public java.io.PrintStream debugStream = System.out;

    /** Set debug output. */
    public void setDebugStream(java.io.PrintStream ds) {
        debugStream = ds;
    }

    //private final int jjStopStringLiteralDfa_0(int pos, long active0) {
    //    switch (pos) {
    //    default:
    //        return -1;
    //    }
    //}

    private int jjStopAtPos(int pos, int kind) {
        jjmatchedKind = kind;
        jjmatchedPos = pos;
        return pos + 1;
    }

    private int jjMoveStringLiteralDfa0_0() {
        switch (curChar) {
        case 44:
            return jjStopAtPos(0, 16);
        case 59:
            return jjStopAtPos(0, 14);
        case 91:
            return jjStopAtPos(0, 13);
        case 93:
            return jjStopAtPos(0, 15);
        default:
            return jjMoveNfa_0(2, 0);
        }
    }

    static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL,
            0xffffffffffffffffL };

    private int jjMoveNfa_0(int startState, int curPos) {
        int startsAt = 0;
        jjnewStateCnt = 23;
        int i = 1;
        jjstateSet[0] = startState;
        int kind = 0x7fffffff;
        for (;;) {
            if (++jjround == 0x7fffffff)
                ReInitRounds();
            if (curChar < 64) {
                long l = 1L << curChar;
                do {
                    switch (jjstateSet[--i]) {
                    case 2:
                        if ((0x3ff000000000000L & l) != 0L) {
                            if (kind > 5)
                                kind = 5;
                            jjCheckNAddStates(0, 7);
                        } else if ((0x280000000000L & l) != 0L) {
                            if (kind > 11)
                                kind = 11;
                        } else if (curChar == 46)
                            jjCheckNAddTwoStates(7, 11);
                        else if (curChar == 35)
                            jjCheckNAddTwoStates(4, 5);
                        break;
                    case 1:
                        if ((0x3ff008000000000L & l) == 0L)
                            break;
                        if (kind > 9)
                            kind = 9;
                        jjstateSet[jjnewStateCnt++] = 1;
                        break;
                    case 3:
                        if (curChar == 35)
                            jjCheckNAddTwoStates(4, 5);
                        break;
                    case 4:
                        if ((0xffffffffffffdbffL & l) != 0L)
                            jjCheckNAddTwoStates(4, 5);
                        break;
                    case 5:
                        if ((0x2400L & l) != 0L)
                            kind = 12;
                        break;
                    case 6:
                        if (curChar == 46)
                            jjCheckNAddTwoStates(7, 11);
                        break;
                    case 7:
                        if ((0x3ff000000000000L & l) == 0L)
                            break;
                        if (kind > 5)
                            kind = 5;
                        jjCheckNAddTwoStates(7, 8);
                        break;
                    case 9:
                        if ((0x280000000000L & l) != 0L)
                            jjCheckNAdd(10);
                        break;
                    case 10:
                        if ((0x3ff000000000000L & l) == 0L)
                            break;
                        if (kind > 5)
                            kind = 5;
                        jjCheckNAdd(10);
                        break;
                    case 11:
                        if ((0x3ff000000000000L & l) == 0L)
                            break;
                        if (kind > 5)
                            kind = 5;
                        jjCheckNAdd(11);
                        break;
                    case 12:
                        if ((0x3ff000000000000L & l) == 0L)
                            break;
                        if (kind > 5)
                            kind = 5;
                        jjCheckNAddStates(0, 7);
                        break;
                    case 13:
                        if ((0x3ff000000000000L & l) == 0L)
                            break;
                        if (kind > 5)
                            kind = 5;
                        jjCheckNAddTwoStates(13, 8);
                        break;
                    case 14:
                        if ((0x3ff000000000000L & l) == 0L)
                            break;
                        if (kind > 5)
                            kind = 5;
                        jjCheckNAddStates(8, 10);
                        break;
                    case 15:
                        if (curChar == 46)
                            jjCheckNAdd(16);
                        break;
                    case 16:
                        if ((0x3ff000000000000L & l) == 0L)
                            break;
                        if (kind > 5)
                            kind = 5;
                        jjCheckNAddTwoStates(16, 8);
                        break;
                    case 17:
                        if ((0x3ff000000000000L & l) == 0L)
                            break;
                        if (kind > 5)
                            kind = 5;
                        jjCheckNAddTwoStates(17, 18);
                        break;
                    case 18:
                        if (curChar == 46)
                            jjCheckNAdd(19);
                        break;
                    case 19:
                        if ((0x3ff000000000000L & l) == 0L)
                            break;
                        if (kind > 5)
                            kind = 5;
                        jjCheckNAdd(19);
                        break;
                    case 20:
                        if ((0x3ff000000000000L & l) == 0L)
                            break;
                        if (kind > 5)
                            kind = 5;
                        jjCheckNAdd(20);
                        break;
                    case 21:
                        if ((0x3ff000000000000L & l) == 0L)
                            break;
                        if (kind > 10)
                            kind = 10;
                        jjCheckNAddTwoStates(22, 21);
                        break;
                    case 22:
                        if ((0x3ff000000000000L & l) == 0L)
                            break;
                        if (kind > 10)
                            kind = 10;
                        jjCheckNAdd(22);
                        break;
                    default:
                        break;
                    }
                } while (i != startsAt);
            } else if (curChar < 128) {
                long l = 1L << (curChar & 077);
                do {
                    switch (jjstateSet[--i]) {
                    case 2:
                    case 0:
                        if ((0x7fffffe87fffffeL & l) == 0L)
                            break;
                        if (kind > 9)
                            kind = 9;
                        jjCheckNAddTwoStates(0, 1);
                        break;
                    case 1:
                        if ((0x7fffffe87fffffeL & l) == 0L)
                            break;
                        if (kind > 9)
                            kind = 9;
                        jjCheckNAdd(1);
                        break;
                    case 4:
                        jjAddStates(11, 12);
                        break;
                    case 8:
                        if ((0x2000000020L & l) != 0L)
                            jjAddStates(13, 14);
                        break;
                    default:
                        break;
                    }
                } while (i != startsAt);
            } else {
                int i2 = (curChar & 0xff) >> 6;
                long l2 = 1L << (curChar & 077);
                do {
                    switch (jjstateSet[--i]) {
                    case 4:
                        if ((jjbitVec0[i2] & l2) != 0L)
                            jjAddStates(11, 12);
                        break;
                    default:
                        break;
                    }
                } while (i != startsAt);
            }
            if (kind != 0x7fffffff) {
                jjmatchedKind = kind;
                jjmatchedPos = curPos;
                kind = 0x7fffffff;
            }
            ++curPos;
            if ((i = jjnewStateCnt) == (startsAt = 23 - (jjnewStateCnt = startsAt)))
                return curPos;
            try {
                curChar = input_stream.readChar();
            } catch (java.io.IOException e) {
                return curPos;
            }
        }
    }

    static final int[] jjnextStates = { 13, 14, 15, 8, 17, 18, 20, 21, 14, 15,
            8, 4, 5, 9, 10, };

    /** Token literal values. */
    public static final String[] jjstrLiteralImages = { "", null, null, null,
            null, null, null, null, null, null, null, null, null, "\133",
            "\73", "\135", "\54", };

    /** Lexer state names. */
    public static final String[] lexStateNames = { "DEFAULT", };
    static final long[] jjtoToken = { 0x1ee21L, };
    static final long[] jjtoSkip = { 0x101eL, };
    static final long[] jjtoSpecial = { 0x1000L, };
    protected SimpleCharStream input_stream;
    private final int[] jjrounds = new int[23];
    private final int[] jjstateSet = new int[46];
    protected char curChar;

    /** Constructor. */
    public MatrixParserTokenManager(SimpleCharStream stream) {
        if (SimpleCharStream.staticFlag)
            throw new Error(
                    "ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
        input_stream = stream;
    }

    /** Constructor. */
    public MatrixParserTokenManager(SimpleCharStream stream, int lexState) {
        this(stream);
        SwitchTo(lexState);
    }

    /** Reinitialise parser. */
    public void ReInit(SimpleCharStream stream) {
        jjmatchedPos = jjnewStateCnt = 0;
        curLexState = defaultLexState;
        input_stream = stream;
        ReInitRounds();
    }

    private void ReInitRounds() {
        int i;
        jjround = 0x80000001;
        for (i = 23; i-- > 0;)
            jjrounds[i] = 0x80000000;
    }

    /** Reinitialise parser. */
    public void ReInit(SimpleCharStream stream, int lexState) {
        ReInit(stream);
        SwitchTo(lexState);
    }

    /** Switch to specified lex state. */
    public void SwitchTo(int lexState) {
        if (lexState >= 1 || lexState < 0)
            throw new TokenMgrError("Error: Ignoring invalid lexical state : "
                    + lexState + ". State unchanged.",
                    TokenMgrError.INVALID_LEXICAL_STATE);
        else
            curLexState = lexState;
    }

    protected Token jjFillToken() {
        final Token t;
        final String curTokenImage;
        final int beginLine;
        final int endLine;
        final int beginColumn;
        final int endColumn;
        String im = jjstrLiteralImages[jjmatchedKind];
        curTokenImage = (im == null) ? input_stream.GetImage() : im;
        beginLine = input_stream.getBeginLine();
        beginColumn = input_stream.getBeginColumn();
        endLine = input_stream.getEndLine();
        endColumn = input_stream.getEndColumn();
        t = Token.newToken(jjmatchedKind, curTokenImage);

        t.beginLine = beginLine;
        t.endLine = endLine;
        t.beginColumn = beginColumn;
        t.endColumn = endColumn;

        return t;
    }

    int curLexState = 0;
    int defaultLexState = 0;
    int jjnewStateCnt;
    int jjround;
    int jjmatchedPos;
    int jjmatchedKind;

    /** Get the next Token. */
    public Token getNextToken() {
        Token specialToken = null;
        Token matchedToken;
        int curPos = 0;

        EOFLoop: for (;;) {
            try {
                curChar = input_stream.BeginToken();
            } catch (java.io.IOException e) {
                jjmatchedKind = 0;
                matchedToken = jjFillToken();
                matchedToken.specialToken = specialToken;
                return matchedToken;
            }

            try {
                input_stream.backup(0);
                while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L)
                    curChar = input_stream.BeginToken();
            } catch (java.io.IOException e1) {
                continue EOFLoop;
            }
            jjmatchedKind = 0x7fffffff;
            jjmatchedPos = 0;
            curPos = jjMoveStringLiteralDfa0_0();
            if (jjmatchedKind != 0x7fffffff) {
                if (jjmatchedPos + 1 < curPos)
                    input_stream.backup(curPos - jjmatchedPos - 1);
                if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
                    matchedToken = jjFillToken();
                    matchedToken.specialToken = specialToken;
                    return matchedToken;
                } else {
                    if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
                        matchedToken = jjFillToken();
                        if (specialToken == null)
                            specialToken = matchedToken;
                        else {
                            matchedToken.specialToken = specialToken;
                            specialToken = (specialToken.next = matchedToken);
                        }
                    }
                    continue EOFLoop;
                }
            }
            int error_line = input_stream.getEndLine();
            int error_column = input_stream.getEndColumn();
            String error_after = null;
            boolean EOFSeen = false;
            try {
                input_stream.readChar();
                input_stream.backup(1);
            } catch (java.io.IOException e1) {
                EOFSeen = true;
                error_after = curPos <= 1 ? "" : input_stream.GetImage();
                if (curChar == '\n' || curChar == '\r') {
                    error_line++;
                    error_column = 0;
                } else
                    error_column++;
            }
            if (!EOFSeen) {
                input_stream.backup(1);
                error_after = curPos <= 1 ? "" : input_stream.GetImage();
            }
            throw new TokenMgrError(EOFSeen, curLexState, error_line,
                    error_column, error_after, curChar,
                    TokenMgrError.LEXICAL_ERROR);
        }
    }

    private void jjCheckNAdd(int state) {
        if (jjrounds[state] != jjround) {
            jjstateSet[jjnewStateCnt++] = state;
            jjrounds[state] = jjround;
        }
    }

    private void jjAddStates(int start, int end) {
        do {
            jjstateSet[jjnewStateCnt++] = jjnextStates[start];
        } while (start++ != end);
    }

    private void jjCheckNAddTwoStates(int state1, int state2) {
        jjCheckNAdd(state1);
        jjCheckNAdd(state2);
    }

    private void jjCheckNAddStates(int start, int end) {
        do {
            jjCheckNAdd(jjnextStates[start]);
        } while (start++ != end);
    }

}
