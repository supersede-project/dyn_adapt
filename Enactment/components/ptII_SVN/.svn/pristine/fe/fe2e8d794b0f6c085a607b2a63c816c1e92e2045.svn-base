<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="TCPSocketDoubleArrayBatched" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={4, 23, 1077, 636}, maximized=false}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[843, 526]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.1869839225790129">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{198.89972686767578, 124.53926029640371}">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="stopTime" class="ptolemy.data.expr.Parameter" value="2.0">
        </property>
        <property name="stopWhenQueueIsEmpty" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-55.0, -65.0]">
        </property>
    </property>
    <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 0.0, 1.0}">
        </property>
        <property name="bold" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Demonstrate transmission of an array of numbers&#10;from client to server and back, but where message&#10;framing is used so that the array is received as a&#10;single message rather than a sequence of numbers.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[10.0, -95.0]">
        </property>
    </property>
    <entity name="ServerReceived" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={907, 445, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[70.0, 150.0]">
        </property>
    </entity>
    <entity name="Const" class="ptolemy.actor.lib.Const">
        <property name="value" class="ptolemy.data.expr.Parameter" value="{1.1, 1.2}">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="value">
            </property>
            <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="40">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[160.0, 5.0]">
        </property>
    </entity>
    <entity name="ClientReceived" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={907, 655, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[460.0, 40.0]">
        </property>
    </entity>
    <entity name="TCPSocketClient" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor sends and/or receives messages from a TCP socket at&#10; *  the specified host and port. If the value of the `port` input is initially&#10; *  negative, then this accessor waits until it receives a non-negative `port`&#10; *  input before making a connection. Otherwise,&#10; *  upon initialization, it initiates a connection to the&#10; *  specified server. If at any time during execution it receives&#10; *  a 'port' input, then it will close any open socket and, if the new&#10; *  'port' value is non-negative, open&#10; *  a new socket to the current 'host' and 'port'.&#10; *  &#10; *  When the connection is established, a `true` boolean is sent to&#10; *  the `connected` output. If the connection is broken during execution, then a `false`&#10; *  boolean is sent to the `connected` output. The swarmlet could respond to this by&#10; *  retrying to connect (send an event to either the `port` or `host` input).&#10; *  &#10; *  Whenever an input is received on the `toSend` input,&#10; *  the data on that input is sent to the socket. If the socket is not yet open,&#10; *  this accessor will, by default, queue the message to send when a socket next opens,&#10; *  unless the `discardMessagesBeforeOpen` parameter is true, in which case,&#10; *  input messages that are received before the socket is opened will be&#10; *  discarded.&#10; *&#10; *  Whenever a message is received from the socket, that message is&#10; *  produced on the `received` output.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the  connection.&#10; *&#10; *  The send and receive types can be any of those supported by the host.&#10; *  The list of supported types will be provided as options for the `sendType`&#10; *  and `receiveType` parameter. For the Ptolemy II host, these include at&#10; *  least 'string', 'number', 'image', and a variety of numeric types.&#10; *&#10; *  If both ends of the socket are known to be JavaScript clients,&#10; *  then you should use the 'number' data type for numeric data.&#10; *  If one end or the other is not JavaScript, then&#10; *  you can use more specified types such as 'float' or 'int', if they&#10; *  are supported by the host. In all cases, received numeric&#10; *  data will be converted to JavaScript 'number' when emitted.&#10; *  For sent data, this will try to convert a JavaScript number&#10; *  to the specified type. The type 'number' is equivalent&#10; *  to 'double'.&#10; *&#10; *  When type conversions are needed, e.g. when you send a double&#10; *  with `sendType` set to int, or an int with `sendType` set to byte,&#10; *  then a &quot;primitive narrowing conversion&quot; will be applied, as specified here:&#10; *  https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&#10; *&#10; *  For numeric types, you can also send an array with a single call&#10; *  to this.send(). The elements of the array will be sent in sequence all&#10; *  at once, and may be received in one batch. If both ends have&#10; *  `rawBytes` set to false (specifying message framing), then these&#10; *  elements will be emitted at the receiving end all at once in a single&#10; *  array. Otherwise, they will be emitted one at a time.&#10; *&#10; *  For strings, you can also send an array of strings in a single call,&#10; *  but these will be simply be concatenated and received as a single string.&#10; *&#10; *  If the `rawBytes` option is set to false, then each data item provided on `toSend`,&#10; *  of any type or array of types, will be coalesced into a single message and&#10; *  the receiving end (if it also has `rawBytes` set to false) will emit the entire&#10; *  message, and only the message, exactly once.  Otherwise, a message may get&#10; *  fragmented, emitted in pieces, or coalesced with subsequent messages.&#10; *&#10; *  When a model with an instance of this accessor stops executing, there&#10; *  are two mechanisms by which data in transit can be lost. In both cases, warning&#10; *  messages or error messages will be issued to the host to be displayed or otherwise&#10; *  handled as the host sees fit.&#10; *&#10; *  * First, there might be queued messages that were received on `toSend` but have not yet&#10; *    been sent, either because the socket has not yet been opened or because&#10; *    it was closed from the other side.&#10; *  * Second, a message might be received from the server after shutdown has commenced.&#10; *    In particular, received messages are handled asynchronously by a handler function&#10; *    that can be invoked at any time, and that handler might be invoked after it is no&#10; *    longer possible for this accessor to produce outputs (it has entered its wrapup&#10; *    phase of execution).&#10; *&#10; *&#10; *  The server might similarly lose messages by the same two mechanisms occurring&#10; *  on the server side. In that case, messages will presumably be displayed on the&#10; *  server side.&#10; *&#10; *  Accessors that extend this one can override the `toSendInputHandler` function&#10; *  to customize what is sent.&#10; *&#10; *  This accessor requires the 'socket' module.&#10; *&#10; *  @accessor net/TCPSocketClient&#10; *&#10; *  @input {string} host The IP address or domain name of server. Defaults to 'localhost'.&#10; *  @input {int} port The port on the server to connect to. Defaults to -1, which means&#10; *   wait for a non-negative input before connecting.&#10; *  @input toSend The data to be sent over the socket.&#10; *  @output {boolean} connected Output `true` on connected and `false` on disconnected.&#10; *  @output received The data received from the web socket server.&#10; *&#10; *  @parameter {int} connectTimeout The time to wait (in milliseconds) before declaring&#10; *    a connection attempt to have failed. This defaults to 6000.&#10; *  @parameter {int} idleTimeout The amount of idle time in seconds that will cause&#10; *    a disconnection of a socket. This defaults to 0, which means no&#10; *    timeout.&#10; *  @parameter {boolean} discardMessagesBeforeOpen If true, then discard any messages&#10; *    passed to SocketClient.send() before the socket is opened. If false,&#10; *    then queue the messages to be sent when the socket opens. This&#10; *    defaults to false.&#10; *  @parameter {boolean} keepAlive Whether to keep a connection alive and reuse it. This&#10; *    defaults to true.&#10; *  @parameter {int} maxUnsentMessages The maximum number of unsent messages to queue before&#10; *    further calls to this.send() will fail. A value of 0 means no limit.&#10; *    This defaults to 100.&#10; *  @parameter {boolean} noDelay If true, data as sent as soon as it is available (the default).&#10; *    If false, data may be accumulated until a reasonable packet size is formed&#10; *    in order to make more efficient use of the network (using Nagle's algorithm).&#10; *  @parameter {string} pfxKeyCertPassword If sslTls is set to true and the server requires&#10; *    client authentication, then this option needs to specify the password for the pfx key-cert&#10; *    file specified by pfxKeyCertPath.&#10; *  @parameter {string} pfxKeyCertPath If sslTls is set to true and the server requires&#10; *    client authentication, then this option needs to specify the fully qualified filename for &#10; *    the file that stores the private key and certificate that this client will use to authenticate&#10; *    itself to the server. This path can be any of those understood by the Ptolemy host, &#10; *    e.g. paths beginning with $CLASSPATH/.&#10; *  @parameter {boolean} rawBytes If true (the default), then transmit only the data bytes provided&#10; *    to this.send() without any header. If false, then prepend sent data with length&#10; *    information and assume receive data starts with length information.&#10; *    Setting this false on both ends will ensure that each data item passed to&#10; *    this.send() is emitted once in its entirety at the receiving end, as a single&#10; *    message. When this is false, the receiving end can emit a partially received&#10; *    message or could concatenate two messages and emit them together.&#10; *  @parameter {int} receiveBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} receiveType See above.&#10; *  @parameter {int} reconnectAttempts The number of times to try to reconnect.&#10; *    If this is greater than 0, then a failure to attempt will trigger&#10; *    additional attempts. This defaults to 10.&#10; *  @parameter {int} reconnectInterval The time between reconnect attempts, in&#10; *    milliseconds. This defaults to 1000 (1 second).&#10; *  @parameter {int} sendBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} sendType See above.&#10; *  @parameter {boolean} sslTls Whether SSL/TLS is enabled. This defaults to false.&#10; *  @parameter {boolean} trustAll Whether to trust servers. This defaults to false.&#10; *    Setting it to true means that if sslTls is set to true, then&#10; *    any certificate provided by the server will be trusted.&#10; *    FIXME: Need to provide a trusted list if this is false.&#10; *  @parameter {string} trustedCACertPath If sslTls is set to true and trustAll is&#10; *    set to false, then this option needs to specify the fully qualified filename&#10; *    for the file that stores the certificate of a certificate authority (CA) that&#10; *    this client will use to verify server certificates. This path can be any of those&#10; *    understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10; *    FIXME: Need to be a list of paths for certificates rather than a single path.&#10; *&#10; *  @author Edward A. Lee, Hokeun Kim&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*global console, error, exports */&#10;/*jshint globalstrict: true */&#10;&quot;use strict&quot;;&#10;&#10;var socket = require('socket');&#10;var client = null;&#10;var running = false;&#10;var pendingSends = [];&#10;var previousHost, previousPort;&#10;&#10;/** Set up the accessor by defining the parameters, inputs, and outputs. */&#10;exports.setup = function () {&#10;    this.input('host', {&#10;        type : 'string',&#10;        value : 'localhost'&#10;    });&#10;    this.input('port', {&#10;        type : 'int',&#10;        value : -1&#10;    });&#10;    // This input is added after host and port so that if there are&#10;    // simultaneous inputs, host and port are handled first.&#10;    this.input('toSend');&#10;    &#10;    this.output('connected', {&#10;        type : 'boolean'&#10;    });&#10;    this.output('received');&#10;    &#10;    // The parameters are in alphabetical order.&#10;    this.parameter('connectTimeout', {&#10;        value: 6000,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('discardMessagesBeforeOpen', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    this.parameter('idleTimeout', {&#10;        value: 0,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('keepAlive', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    this.parameter('maxUnsentMessages', {&#10;        value: 100,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('noDelay', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    this.parameter('pfxKeyCertPassword', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    this.parameter('pfxKeyCertPath', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    this.parameter('rawBytes', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    this.parameter('receiveBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('receiveType', {&#10;        type : 'string',&#10;        value : 'string',&#10;    });&#10;    this.parameter('reconnectAttempts', {&#10;        type : 'int',&#10;        value : 10&#10;    });&#10;    this.parameter('reconnectInterval', {&#10;        type : 'int',&#10;        value : 1000&#10;    });&#10;    this.parameter('sendBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('sendType', {&#10;        type : 'string',&#10;        value : 'string',&#10;    });&#10;    this.parameter('sslTls', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    this.parameter('trustAll', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    this.parameter('trustedCACertPath', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    &#10;    // Attempt to add a list of options for types, but do not error out&#10;    // if the socket module is not supported by the host.&#10;    try {&#10;        this.parameter('receiveType', {&#10;            options : socket.supportedReceiveTypes()&#10;        });&#10;        this.parameter('sendType', {&#10;            options : socket.supportedSendTypes()&#10;        });&#10;    } catch(err) {&#10;        this.error(err);&#10;    }&#10;};&#10;&#10;/** Handle input on 'toSend' by sending the specified data to the server. */&#10;exports.toSendInputHandler = function () {&#10;	// May be receiving inputs before client has been set.&#10;	if (client) {&#10;    	client.send(this.get('toSend'));&#10;	} else {&#10;        if (!this.getParameter('discardMessagesBeforeOpen')) {&#10;            var maxUnsentMessages = this.getParameter('maxUnsentMessages');&#10;            if (maxUnsentMessages &gt; 0 &amp;&amp; pendingSends.length &gt;= maxUnsentMessages) {&#10;                this.error(&quot;Maximum number of unsent messages has been exceeded: &quot; +&#10;                    maxUnsentMessages +&#10;                    &quot;. Consider setting discardMessagesBeforeOpen to true.&quot;);&#10;                return;&#10;            }&#10;            pendingSends.push(data);&#10;        } else {&#10;            console.log('Discarding data because socket is not open.');&#10;        }&#10;	}&#10;};&#10;&#10;/** Set up input handlers, and if the current value of the 'port' input is&#10; *  non-negative, initiate a connection to the server using the&#10; *  current parameter values, and&#10; *  set up handlers for for establishment of the connection, incoming data,&#10; *  errors, and closing from the server.&#10; */&#10;exports.initialize = function () {&#10;	this.addInputHandler('host', this.exports.connect.bind(this));&#10;	this.addInputHandler('port', this.exports.connect.bind(this));&#10;    this.addInputHandler('toSend', exports.toSendInputHandler.bind(this));&#10;    this.exports.connect.call(this);&#10;    running = true;&#10;};&#10;&#10;/** Initiate a connection to the server using the current parameter values,&#10; *  set up handlers for for establishment of the connection, incoming data,&#10; *  errors, and closing from the server, and set up a handler for inputs&#10; *  on the toSend() input port.&#10; */&#10;exports.connect = function () {&#10;	// Note that if 'host' and 'port' both receive new data in the same&#10;	// reaction, then this will be invoked twice. But we only want to open&#10;	// the socket once.  This is fairly tricky.&#10;	&#10;	var portValue = this.get('port');&#10;	if (portValue &lt; 0) {&#10;		// No port is specified. This could be a signal to close a previously&#10;		// open socket.&#10;		if (client &amp;&amp; client.isOpen()) {&#10;			client.close();&#10;		}&#10;		previousPort = null;&#10;		previousHost = null;&#10;		return;&#10;	}&#10;	&#10;	var hostValue = this.get('host');&#10;	if (previousHost === hostValue &amp;&amp; previousPort === portValue) {&#10;		// A request to open a client for this host/port pair has already&#10;		// been made and has not yet been closed or failed with an error.&#10;		return;&#10;	}&#10;	// Record the host/port pair that we are now opening.&#10;	previousHost = hostValue;&#10;	previousPort = portValue;&#10;	&#10;	if (client &amp;&amp; client.isOpen()) {&#10;		// Either the host or the port has changed. Close the previous socket.&#10;		client.close();&#10;	}&#10;	// Create a new SocketClient.&#10;    client = new socket.SocketClient(portValue, hostValue,&#10;        {&#10;            'connectTimeout' : this.getParameter('connectTimeout'),&#10;            'discardMessagesBeforeOpen' : this.getParameter('discardMessagesBeforeOpen'),&#10;            'idleTimeout' : this.getParameter('idleTimeout'),&#10;            'keepAlive' : this.getParameter('keepAlive'),&#10;            'maxUnsentMessages' : this.getParameter('maxUnsentMessages'),&#10;            'noDelay' : this.getParameter('noDelay'),&#10;            'pfxKeyCertPassword' : this.getParameter('pfxKeyCertPassword'),&#10;            'pfxKeyCertPath' : this.getParameter('pfxKeyCertPath'),&#10;            'rawBytes' : this.getParameter('rawBytes'),&#10;            'receiveBufferSize' : this.getParameter('receiveBufferSize'),&#10;            'receiveType' : this.getParameter('receiveType'),&#10;            'reconnectAttempts' : this.getParameter('reconnectAttempts'),&#10;            'reconnectInterval' : this.getParameter('reconnectInterval'),&#10;            'sendBufferSize' : this.getParameter('sendBufferSize'),&#10;            'sendType' : this.getParameter('sendType'),&#10;            'sslTls' : this.getParameter('sslTls'),&#10;            'trustAll' : this.getParameter('trustAll'),&#10;            'trustedCACertPath' : this.getParameter('trustedCACertPath')&#10;        }&#10;    );&#10;    &#10;    var self = this;&#10;&#10;    client.on('open', function() {&#10;        console.log('Status: Connection established');&#10;        self.send('connected', true);&#10;        &#10;        // If there are pending sends, send them now.&#10;        // Note this implementation requires that the host invoke&#10;        // this callback function atomically w.r.t. the input handler&#10;        // that adds messages to the pendingSends queue.&#10;        for (var i = 0; i &lt; pendingSends.length; i++) {&#10;        	client.send(pendingSends[i]);&#10;        }&#10;        pendingSends = [];&#10;    });&#10;    client.on('data', function(data) {&#10;        self.send('received', data);&#10;    });&#10;    client.on('close', function() {&#10;    	previousHost = null;&#10;    	previousPort = null;&#10;        console.log('Connection closed.');&#10;        // NOTE: Even if running is true, it can occur that it is too late&#10;        // to send the message (the wrapup process has been started), in which case&#10;        // the message may not be received.&#10;        if (running) {&#10;            self.send('connected', false);&#10;        }&#10;    });&#10;    client.on('error', function (message) {&#10;    	previousHost = null;&#10;    	previousPort = null;&#10;        self.error(message);&#10;    });&#10;    &#10;    client.open();&#10;};&#10;&#10;/** Return true if this client has an open connection to the server. */&#10;exports.isOpen = function () {&#10;    return client.isOpen();&#10;};&#10;&#10;/** Close the web socket connection. */&#10;exports.wrapup = function () {&#10;    running = false;&#10;    if (client) {&#10;        client.close();&#10;        console.log('Status: Connection closed in wrapup.');&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://terraswarm.org/accessors/net/TCPSocketClient.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="number">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="number">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[305.0, 30.0]">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor sends and/or receives messages from a TCP socket at&#10; the specified host and port. If the value of the &lt;code&gt;port&lt;/code&gt; input is initially&#10; negative, then this accessor waits until it receives a non-negative &lt;code&gt;port&lt;/code&gt;&#10; input before making a connection. Otherwise,&#10; upon initialization, it initiates a connection to the&#10; specified server. If at any time during execution it receives&#10; a 'port' input, then it will close any open socket and, if the new&#10; 'port' value is non-negative, open&#10; a new socket to the current 'host' and 'port'.&lt;/p&gt;&#10;&lt;p&gt; When the connection is established, a &lt;code&gt;true&lt;/code&gt; boolean is sent to&#10; the &lt;code&gt;connected&lt;/code&gt; output. If the connection is broken during execution, then a &lt;code&gt;false&lt;/code&gt;&#10; boolean is sent to the &lt;code&gt;connected&lt;/code&gt; output. The swarmlet could respond to this by&#10; retrying to connect (send an event to either the &lt;code&gt;port&lt;/code&gt; or &lt;code&gt;host&lt;/code&gt; input).&lt;/p&gt;&#10;&lt;p&gt; Whenever an input is received on the &lt;code&gt;toSend&lt;/code&gt; input,&#10; the data on that input is sent to the socket. If the socket is not yet open,&#10; this accessor will, by default, queue the message to send when a socket next opens,&#10; unless the &lt;code&gt;discardMessagesBeforeOpen&lt;/code&gt; parameter is true, in which case,&#10; input messages that are received before the socket is opened will be&#10; discarded.&lt;/p&gt;&#10;&lt;p&gt; Whenever a message is received from the socket, that message is&#10; produced on the &lt;code&gt;received&lt;/code&gt; output.&lt;/p&gt;&#10;&lt;p&gt; When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the  connection.&lt;/p&gt;&#10;&lt;p&gt; The send and receive types can be any of those supported by the host.&#10; The list of supported types will be provided as options for the &lt;code&gt;sendType&lt;/code&gt;&#10; and &lt;code&gt;receiveType&lt;/code&gt; parameter. For the Ptolemy II host, these include at&#10; least 'string', 'number', 'image', and a variety of numeric types.&lt;/p&gt;&#10;&lt;p&gt; If both ends of the socket are known to be JavaScript clients,&#10; then you should use the 'number' data type for numeric data.&#10; If one end or the other is not JavaScript, then&#10; you can use more specified types such as 'float' or 'int', if they&#10; are supported by the host. In all cases, received numeric&#10; data will be converted to JavaScript 'number' when emitted.&#10; For sent data, this will try to convert a JavaScript number&#10; to the specified type. The type 'number' is equivalent&#10; to 'double'.&lt;/p&gt;&#10;&lt;p&gt; When type conversions are needed, e.g. when you send a double&#10; with &lt;code&gt;sendType&lt;/code&gt; set to int, or an int with &lt;code&gt;sendType&lt;/code&gt; set to byte,&#10; then a &amp;quot;primitive narrowing conversion&amp;quot; will be applied, as specified here:&#10; https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&lt;/p&gt;&#10;&lt;p&gt; For numeric types, you can also send an array with a single call&#10; to this.send(). The elements of the array will be sent in sequence all&#10; at once, and may be received in one batch. If both ends have&#10; &lt;code&gt;rawBytes&lt;/code&gt; set to false (specifying message framing), then these&#10; elements will be emitted at the receiving end all at once in a single&#10; array. Otherwise, they will be emitted one at a time.&lt;/p&gt;&#10;&lt;p&gt; For strings, you can also send an array of strings in a single call,&#10; but these will be simply be concatenated and received as a single string.&lt;/p&gt;&#10;&lt;p&gt; If the &lt;code&gt;rawBytes&lt;/code&gt; option is set to false, then each data item provided on &lt;code&gt;toSend&lt;/code&gt;,&#10; of any type or array of types, will be coalesced into a single message and&#10; the receiving end (if it also has &lt;code&gt;rawBytes&lt;/code&gt; set to false) will emit the entire&#10; message, and only the message, exactly once.  Otherwise, a message may get&#10; fragmented, emitted in pieces, or coalesced with subsequent messages.&lt;/p&gt;&#10;&lt;p&gt; When a model with an instance of this accessor stops executing, there&#10; are two mechanisms by which data in transit can be lost. In both cases, warning&#10; messages or error messages will be issued to the host to be displayed or otherwise&#10; handled as the host sees fit.&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;First, there might be queued messages that were received on &lt;code&gt;toSend&lt;/code&gt; but have not yet&#10;been sent, either because the socket has not yet been opened or because&#10;it was closed from the other side.&lt;/li&gt;&#10;&lt;li&gt;Second, a message might be received from the server after shutdown has commenced.&#10;In particular, received messages are handled asynchronously by a handler function&#10;that can be invoked at any time, and that handler might be invoked after it is no&#10;longer possible for this accessor to produce outputs (it has entered its wrapup&#10;phase of execution).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; The server might similarly lose messages by the same two mechanisms occurring&#10; on the server side. In that case, messages will presumably be displayed on the&#10; server side.&lt;/p&gt;&#10;&lt;p&gt; Accessors that extend this one can override the &lt;code&gt;toSendInputHandler&lt;/code&gt; function&#10; to customize what is sent.&lt;/p&gt;&#10;&lt;p&gt; This accessor requires the 'socket' module.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee, Hokeun Kim">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="receiveType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See above.">
            </property>
            <property name="sendType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See above.">
            </property>
            <property name="host (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The IP address or domain name of server. Defaults to 'localhost'.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The port on the server to connect to. Defaults to 4000.">
            </property>
            <property name="connectTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The time to wait (in milliseconds) before declaring&#10;   a connection attempt to have failed. This defaults to 6000.">
            </property>
            <property name="discardMessagesBeforeOpen (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, then discard any messages&#10;   passed to SocketClient.send() before the socket is opened. If false,&#10;   then queue the messages to be sent when the socket opens. This&#10;   defaults to false.">
            </property>
            <property name="idleTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The amount of idle time in seconds that will cause&#10;   a disconnection of a socket. This defaults to 0, which means no&#10;   timeout.">
            </property>
            <property name="keepAlive (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether to keep a connection alive and reuse it. This&#10;   defaults to true.">
            </property>
            <property name="maxUnsentMessages (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The maximum number of unsent messages to queue before&#10;   further calls to this.send() will fail. A value of 0 means no limit.&#10;   This defaults to 100.">
            </property>
            <property name="noDelay (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, data as sent as soon as it is available (the default).&#10;   If false, data may be accumulated until a reasonable packet size is formed&#10;   in order to make more efficient use of the network (using Nagle's algorithm).">
            </property>
            <property name="rawBytes (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true (the default), then transmit only the data bytes provided&#10;   to this.send() without any header. If false, then prepend sent data with length&#10;   information and assume receive data starts with length information.&#10;   Setting this false on both ends will ensure that each data item passed to&#10;   this.send() is emitted once in its entirety at the receiving end, as a single&#10;   message. When this is false, the receiving end can emit a partially received&#10;   message or could concatenate two messages and emit them together.">
            </property>
            <property name="receiveBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="reconnectAttempts (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The number of times to try to reconnect.&#10;   If this is greater than 0, then a failure to attempt will trigger&#10;   additional attempts. This defaults to 10.">
            </property>
            <property name="reconnectInterval (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The time between reconnect attempts, in&#10;   milliseconds. This defaults to 1000 (1 second).">
            </property>
            <property name="reconnectOnClose (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, then if the connection is closed&#10;   before this accessor is wrapped up, then attempt to reconnect.">
            </property>
            <property name="sendBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="sslTls (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether SSL/TLS is enabled. This defaults to false.">
            </property>
            <property name="trustAll (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether to trust servers. This defaults to false.&#10;   Setting it to true means that if sslTls is set to true, then&#10;   any certificate provided by the server will be trusted.&#10;   FIXME: Need to provide a trusted list if this is false.">
            </property>
            <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" value="The data to be sent over the socket.">
            </property>
            <property name="connected (port)" class="ptolemy.kernel.util.StringAttribute" value="Output `true` on connected and `false` on disconnected.">
            </property>
            <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" value="The data received from the web socket server.">
            </property>
            <property name="pfxKeyCertPassword (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and the server requires&#10;   client authentication, then this option needs to specify the password for the pfx key-cert&#10;   file specified by pfxKeyCertPath.">
            </property>
            <property name="pfxKeyCertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and the server requires&#10;   client authentication, then this option needs to specify the fully qualified filename for &#10;   the file that stores the private key and certificate that this client will use to authenticate&#10;   itself to the server. This path can be any of those understood by the Ptolemy host, &#10;   e.g. paths beginning with $CLASSPATH/.">
            </property>
            <property name="trustedCACertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and trustAll is&#10;   set to false, then this option needs to specify the fully qualified filename&#10;   for the file that stores the certificate of a certificate authority (CA) that&#10;   this client will use to verify server certificates. This path can be any of those&#10;   understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10;   FIXME: Need to be a list of paths for certificates rather than a single path.">
            </property>
            <property name="host (port)" class="ptolemy.kernel.util.StringAttribute" value="The IP address or domain name of server. Defaults to 'localhost'.">
            </property>
            <property name="port (port)" class="ptolemy.kernel.util.StringAttribute" value="The port on the server to connect to. Defaults to -1, which means&#10;  wait for a non-negative input before connecting.">
            </property>
        </property>
        <property name="pfxKeyCertPassword" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="pfxKeyCertPath" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="trustedCACertPath" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="host" class="ptolemy.actor.parameters.PortParameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="port" class="ptolemy.actor.parameters.PortParameter" value="-1">
        </property>
        <port name="host" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="port" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
        </port>
    </entity>
    <entity name="TCPSocketServer" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor establishes a server that can accept connection requests for&#10; *  a TCP socket and can send and/or receives messages from the client that makes the&#10; *  request.&#10; *&#10; *  When the server is listening and accepting connections, the port on which it is&#10; *  listening is emitted on the `listening` output port.&#10; *&#10; *  When a connection is established, this accessor outputs on the `connection` output&#10; *  an object with the following properties:&#10; *&#10; *  * **id**: A unique ID identifying the connection (a positive integer).&#10; *  * **remoteHost**: The IP address of the remote host for the socket (a string).&#10; *  * **remotePort**: The port of the remote host for the socket (an integer).&#10; *  * **status**: The string 'open'.&#10; *&#10; *&#10; *  When the connection is closed, the same object as above is produced on the&#10; *  `connection` output, except with status being 'closed'.&#10; *&#10; *  When data is received from the connection, two outputs are produced.&#10; *  The data itself is produced on the `received` output.  The ID of the connection&#10; *  over which the data arrived is produced on the `receivedID` output.&#10; *&#10; *  To send data over a connection, provide the data on the `toSend` input port&#10; *  and the ID of the connection on the `toSendID` input port.  To send to all open&#10; *  connections, provide an ID of 0 (zero).&#10; *&#10; *  The send and receive types can be any of those supported by the host.&#10; *  The list of supported types will be provided as options for the `sendType`&#10; *  and `receiveType` parameter. For the Ptolemy II host, these include at&#10; *  least 'string', 'number', 'image', and a variety of numeric types.&#10; *&#10; *  If both ends of the socket are known to be JavaScript clients,&#10; *  then you should use the 'number' data type for numeric data.&#10; *  If one end or the other is not JavaScript, then&#10; *  you can use more specified types such as 'float' or 'int', if they&#10; *  are supported by the host. In all cases, received numeric&#10; *  data will be converted to JavaScript 'number' when emitted.&#10; *  For sent data, this will try to convert a JavaScript number&#10; *  to the specified type. The type 'number' is equivalent&#10; *  to 'double'.&#10; *&#10; *  When type conversions are needed, e.g. when you send a double&#10; *  with `sendType` set to int, or an int with `sendType` set to byte,&#10; *  then a &quot;primitive narrowing conversion&quot; will be applied, as specified here:&#10; *  https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&#10; *&#10; *  For numeric types, you can also send an array with a single call&#10; *  to this.send(). The elements of the array will be sent in sequence all&#10; *  at once, and may be received in one batch. If both ends have&#10; *  `rawBytes` set to false (specifying message framing), then these&#10; *  elements will be emitted at the receiving end all at once in a single&#10; *  array. Otherwise, they will be emitted one at a time.&#10; *&#10; *  For strings, you can also send an array of strings in a single call,&#10; *  but these will be simply be concatenated and received as a single string.&#10; *&#10; *  If the `rawBytes` option is set to false, then each data item that arrives on&#10; *  `toSend`, of any type or array of types, will be coalesced into a single message and&#10; *  the receiving end (if it also has `rawBytes` set to false) will emit the entire&#10; *  message, and only the message, exactly once.  Otherwise, a message may get&#10; *  fragmented, emitted in pieces, or coalesced with subsequent messages.&#10; *&#10; *  When a model with an instance of this accessor stops executing, there&#10; *  are two mechanisms by which data in transit can be lost. In both cases, warning&#10; *  messages or error messages will be issued to the host to be displayed or otherwise&#10; *  handled as the host sees fit.&#10; *&#10; *  * First, there might be queued messages that were received on `toSend` but have not yet&#10; *    been sent, either because the socket has not yet been opened or because&#10; *    it was closed from the other side.&#10; *  * Second, a message might be received from the server after shutdown has commenced.&#10; *    In particular, received messages are handled asynchronously by a handler function&#10; *    that can be invoked at any time, and that handler might be invoked after it is no&#10; *    longer possible for this accessor to produce outputs (it has entered its wrapup&#10; *    phase of execution).&#10; *&#10; *  The client might similarly lose messages by the same two mechanisms occurring&#10; *  on the client side. In that case, messages will presumably be displayed on the&#10; *  client side.&#10; *&#10; *  Accessors that extend this one can override the `toSendInputHandler` function&#10; *  to customize what is sent. &#10; *&#10; *  This accessor requires the 'socket' module.&#10; *&#10; *  @accessor net/TCPSocketServer&#10; *&#10; *  @input toSend The data to be sent over the socket.&#10; *  @input toSendID The ID of the connection over which to send the data, where 0 means&#10; *    to send to all open connections.&#10; *  @output {int} listening When the server is listening for connections, this output&#10; *    will produce the port number that the server is listening on&#10; *    (this is useful if the port is specified to be 0).&#10; *  @output connection Output an object with the properties specified above when a&#10; *     connection is established.&#10; *  @output received The data received from the web socket server.&#10; *  @output receivedID The ID of the connection over which data produced on the received&#10; *    output was received. This is a positive integer, as indicated in the connection&#10; *    output.&#10; *&#10; *  @parameter {string} clientAuth One of 'none', 'request', or 'required', meaning&#10; *    whether it requires that a certificate be presented.&#10; *  @parameter {boolean} discardSendToUnopenedSocket If true, then discard any data&#10; *   sent to a socket that is not open. The data will be logged using console.log()&#10; *   instead. This defaults to false.&#10; *  @parameter {string} hostInterface The name of the network interface to use for&#10; *    listening, e.g. 'localhost'. The default is '0.0.0.0', which means to&#10; *    listen on all available interfaces.&#10; *  @parameter {int} idleTimeout The amount of idle time in seconds that will cause&#10; *    a disconnection of a socket. This defaults to 0, which means no&#10; *    timeout.&#10; *  @parameter {boolean} keepAlive Whether to keep a connection alive and reuse it. This&#10; *    defaults to true.&#10; *  @parameter {boolean} noDelay If true, data as sent as soon as it is available&#10; *    (the default). If false, data may be accumulated until a reasonable packet size is&#10; *    formed in order to make more efficient use of the network (using Nagle's algorithm).&#10; *  @parameter {string} pfxKeyCertPassword If sslTls is set to true, then this option&#10; *    needs to specify the password for the pfx key-cert file specified by pfxKeyCertPath.&#10; *  @parameter {string} pfxKeyCertPath If sslTls is set to true, then this option&#10; *    needs to specify the fully qualified filename for the file that stores the&#10; *    private key and certificate that this server will use to identify itself. This path can be&#10; *    any of those understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10; *  @parameter {int} port The default port to listen on. This defaults to 4000.&#10; *    a value of 0 means to choose a random ephemeral free port.&#10; *  @parameter {boolean} rawBytes If true (the default), then transmit only the data bytes provided&#10; *    to this.send() without any header. If false, then prepend sent data with length&#10; *    information and assume receive data starts with length information.&#10; *    Setting this false on both ends will ensure that each data item passed to&#10; *    this.send() is emitted once in its entirety at the receiving end, as a single&#10; *    message. When this is false, the receiving end can emit a partially received&#10; *    message or could concatenate two messages and emit them together.&#10; *  @parameter {int} receiveBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} receiveType See below.&#10; *  @parameter {int} sendBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} sendType See below.&#10; *  @parameter {boolean} sslTls Whether SSL/TLS is enabled. This defaults to false.&#10; *  @parameter {string} trustedCACertPath If sslTls is set to true and this server&#10; *    requests/requires a certificate from the client, then this option needs to specify&#10; *    the filename for the file that stores the certificate of a certificate authority (CA) that&#10; *    this server will use to verify client certificates. This path can be any of those&#10; *    understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10; *    FIXME: Need to be a list of paths for certificates rather than a single path.&#10; *&#10; *  @author Edward A. Lee, Hokeun Kim&#10; *  @version $$Id$$&#10; */&#10;&#10;/* These are needed by JSLint, see https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSLint */&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*global addInputHandler, console, error, exports, get, getParameter, input, onClose, output, parameter, removeInputHandler, require, send */&#10;/*jshint globalstrict: true */&#10;&quot;use strict&quot;;&#10;&#10;var socket = require('socket');&#10;&#10;/** Set up the accessor by defining the parameters, inputs, and outputs. */&#10;exports.setup = function () {&#10;    this.input('toSend');&#10;    this.input('toSendID', {&#10;        type: 'int',&#10;        value: 0&#10;    });&#10;    this.output('listening', {&#10;        type: 'int'&#10;    });&#10;    this.output('connection');&#10;    this.output('received');&#10;    this.output('receivedID');&#10;&#10;    // The parameters below are listed alphabetically.&#10;    this.parameter('clientAuth', {&#10;        type : 'string',&#10;        value : 'none'    // Indicates no SSL/TSL will be used.&#10;    });&#10;    this.parameter('discardSendToUnopenedSocket', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    this.parameter('hostInterface', {&#10;        type : 'string',&#10;        value : '0.0.0.0' // Means listen on all available interfaces.&#10;    });&#10;    this.parameter('idleTimeout', {&#10;        value: 0,         // In seconds. 0 means don't timeout.&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('keepAlive', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    this.parameter('noDelay', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    this.parameter('pfxKeyCertPassword', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    this.parameter('pfxKeyCertPath', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    this.parameter('port', {&#10;        type : 'int',&#10;        value : 4000&#10;    });&#10;    this.parameter('rawBytes', {&#10;        type : 'boolean',&#10;        value : false      // Means to use a messaging protocol.&#10;    });&#10;    this.parameter('receiveBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('receiveType', {&#10;        type : 'string',&#10;        value : 'string',&#10;    });&#10;    this.parameter('sendBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('sendType', {&#10;        type : 'string',&#10;        value : 'string',&#10;    });&#10;    this.parameter('sslTls', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    this.parameter('trustedCACertPath', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    // Attempt to add a list of options for types, but do not error out&#10;    // if the socket module is not supported by the host.&#10;    try {&#10;        this.parameter('receiveType', {&#10;            options : socket.supportedReceiveTypes()&#10;        });&#10;        this.parameter('sendType', {&#10;            options : socket.supportedSendTypes()&#10;        });&#10;    } catch(err) {&#10;        error(err);&#10;    }&#10;};&#10;&#10;var server = null;&#10;var connectionCount = 0;&#10;var sockets = [];&#10;&#10;/** Handle input on 'toSend' by sending to one or all of the open sockets, depending&#10; *  on the most recently received value on the `toSendID` input.&#10; */&#10;exports.toSendInputHandler = function () {&#10;    var dataToSend = this.get('toSend');&#10;    var idToSendTo = this.get('toSendID');&#10;    if (idToSendTo === 0) {&#10;        // Broadcast to all sockets.&#10;        for (var i = 0; i &lt; sockets.length; i++) {&#10;            if (sockets[i]) {&#10;                sockets[i].send(dataToSend);&#10;            }&#10;        }&#10;    } else if (sockets[idToSendTo]) {&#10;        sockets[idToSendTo].send(dataToSend);&#10;    } else {&#10;        var discardSendToUnopenedSocket = this.getParameter('discardSendToUnopenedSocket');&#10;        if (discardSendToUnopenedSocket) {&#10;            console.log('Socket with ID ' + idToSendTo +&#10;                        ' is not open. Discarding data.');&#10;        } else {&#10;            error('Attempting to send data over socket with id ' + idToSendTo +&#10;                    ', but this socket is not open.');&#10;        }&#10;    }&#10;};&#10;&#10;/** Initialize the accessor by starting the server with the current parameter values&#10; *  specifying the options, setting up listeners to be notified when the server is&#10; *  is listening for connections, when a client requests and connection,&#10; *  and when errors occur, and setting up an input handler&#10; *  for data arriving on the toSend input. When a client requests a connection, the&#10; *  handler will open the socket, send a `connection` output, and and set up listeners&#10; *  for incoming data, errors, and closing of the socket from the remote site.&#10; */&#10;exports.initialize = function () {&#10;&#10;    server = new socket.SocketServer(&#10;        {&#10;            'clientAuth' : this.getParameter('clientAuth'),&#10;            'hostInterface' : this.getParameter('hostInterface'),&#10;            'idleTimeout' : this.getParameter('idleTimeout'),&#10;            'keepAlive' : this.getParameter('keepAlive'),&#10;            'noDelay' : this.getParameter('noDelay'),&#10;            'pfxKeyCertPassword' : this.getParameter('pfxKeyCertPassword'),&#10;            'pfxKeyCertPath' : this.getParameter('pfxKeyCertPath'),&#10;            'port' : this.getParameter('port'),&#10;            'rawBytes' : this.getParameter('rawBytes'),&#10;            'receiveBufferSize' : this.getParameter('receiveBufferSize'),&#10;            'receiveType' : this.getParameter('receiveType'),&#10;            'sendBufferSize' : this.getParameter('sendBufferSize'),&#10;            'sendType' : this.getParameter('sendType'),&#10;            'sslTls' : this.getParameter('sslTls'),&#10;            'trustedCACertPath' : this.getParameter('trustedCACertPath')&#10;        }&#10;    );&#10;&#10;    var self = this;&#10;&#10;    server.on('error', function(message) {&#10;        self.error(message);&#10;    });&#10;        &#10;    server.on('listening', function(port) {&#10;        console.log('Server: Listening for socket connection requests on port ' + port);&#10;        self.send('listening', port);&#10;    });&#10;    &#10;    server.on('connection', function(serverSocket) {&#10;    	// serverSocket is an instance of the Socket class defined&#10;    	// in the socket module.&#10;    	connectionCount++;&#10;        var socketInstance = connectionCount;&#10;        var socketID = {&#10;            'id': socketInstance,&#10;            'remoteHost': serverSocket.remoteHost(),&#10;            'remotePort': serverSocket.remotePort(),&#10;            'status': 'open'&#10;        };&#10;        self.send('connection', socketID);&#10;        &#10;        sockets[socketInstance] = serverSocket;&#10;&#10;        serverSocket.on('close', function() {&#10;            socketID.status = 'closed';&#10;            this.send('connection', socketID);&#10;            // Avoid a memory leak here.&#10;            sockets[socketInstance] = null;&#10;        });&#10;        serverSocket.on('data', function(data) {&#10;            self.send('received', data);&#10;            self.send('receivedID', connectionCount);&#10;        });&#10;        serverSocket.on('error', function(message) {&#10;            self.error(message);&#10;        });&#10;    });&#10;    &#10;    // Open the server after setting up all the handlers.&#10;    server.start();&#10;    &#10;    // Bind the input handler to caller's object so that when it is invoked,&#10;    // it is invoked in the context of that object and not this one.&#10;    this.addInputHandler('toSend', exports.toSendInputHandler.bind(this));&#10;};&#10;&#10;/** Close all sockets, unregister event listeners, and stop the server.&#10; */&#10;exports.wrapup = function() {&#10;    sockets = [];&#10;&#10;    if (server !== null) {&#10;        server.stop();&#10;        server = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://terraswarm.org/accessors/net/TCPSocketServer.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="clientAuth" class="ptolemy.data.expr.Parameter" value="none">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.Parameter" value="0.0.0.0">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="keyStorePassword" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="keyStorePath" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="number">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="number">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-75.0, 60.0]">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor establishes a server that can accept connection requests for&#10; a TCP socket and can send and/or receives messages from the client that makes the&#10; request.&lt;/p&gt;&#10;&lt;p&gt; When the server is listening and accepting connections, the port on which it is&#10; listening is emitted on the &lt;code&gt;listening&lt;/code&gt; output port.&lt;/p&gt;&#10;&lt;p&gt; When a connection is established, this accessor outputs on the &lt;code&gt;connection&lt;/code&gt; output&#10; an object with the following properties:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;id&lt;/strong&gt;: A unique ID identifying the connection (a positive integer).&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;remoteHost&lt;/strong&gt;: The IP address of the remote host for the socket (a string).&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;remotePort&lt;/strong&gt;: The port of the remote host for the socket (an integer).&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;status&lt;/strong&gt;: The string 'open'.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; When the connection is closed, the same object as above is produced on the&#10; &lt;code&gt;connection&lt;/code&gt; output, except with status being 'closed'.&lt;/p&gt;&#10;&lt;p&gt; When data is received from the connection, two outputs are produced.&#10; The data itself is produced on the &lt;code&gt;received&lt;/code&gt; output.  The ID of the connection&#10; over which the data arrived is produced on the &lt;code&gt;receivedID&lt;/code&gt; output.&lt;/p&gt;&#10;&lt;p&gt; To send data over a connection, provide the data on the &lt;code&gt;toSend&lt;/code&gt; input port&#10; and the ID of the connection on the &lt;code&gt;toSendID&lt;/code&gt; input port.  To send to all open&#10; connections, provide an ID of 0 (zero).&lt;/p&gt;&#10;&lt;p&gt; The send and receive types can be any of those supported by the host.&#10; The list of supported types will be provided as options for the &lt;code&gt;sendType&lt;/code&gt;&#10; and &lt;code&gt;receiveType&lt;/code&gt; parameter. For the Ptolemy II host, these include at&#10; least 'string', 'number', 'image', and a variety of numeric types.&lt;/p&gt;&#10;&lt;p&gt; If both ends of the socket are known to be JavaScript clients,&#10; then you should use the 'number' data type for numeric data.&#10; If one end or the other is not JavaScript, then&#10; you can use more specified types such as 'float' or 'int', if they&#10; are supported by the host. In all cases, received numeric&#10; data will be converted to JavaScript 'number' when emitted.&#10; For sent data, this will try to convert a JavaScript number&#10; to the specified type. The type 'number' is equivalent&#10; to 'double'.&lt;/p&gt;&#10;&lt;p&gt; When type conversions are needed, e.g. when you send a double&#10; with &lt;code&gt;sendType&lt;/code&gt; set to int, or an int with &lt;code&gt;sendType&lt;/code&gt; set to byte,&#10; then a &amp;quot;primitive narrowing conversion&amp;quot; will be applied, as specified here:&#10; https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&lt;/p&gt;&#10;&lt;p&gt; For numeric types, you can also send an array with a single call&#10; to this.send(). The elements of the array will be sent in sequence all&#10; at once, and may be received in one batch. If both ends have&#10; &lt;code&gt;rawBytes&lt;/code&gt; set to false (specifying message framing), then these&#10; elements will be emitted at the receiving end all at once in a single&#10; array. Otherwise, they will be emitted one at a time.&lt;/p&gt;&#10;&lt;p&gt; For strings, you can also send an array of strings in a single call,&#10; but these will be simply be concatenated and received as a single string.&lt;/p&gt;&#10;&lt;p&gt; If the &lt;code&gt;rawBytes&lt;/code&gt; option is set to false, then each data item that arrives on&#10; &lt;code&gt;toSend&lt;/code&gt;, of any type or array of types, will be coalesced into a single message and&#10; the receiving end (if it also has &lt;code&gt;rawBytes&lt;/code&gt; set to false) will emit the entire&#10; message, and only the message, exactly once.  Otherwise, a message may get&#10; fragmented, emitted in pieces, or coalesced with subsequent messages.&lt;/p&gt;&#10;&lt;p&gt; When a model with an instance of this accessor stops executing, there&#10; are two mechanisms by which data in transit can be lost. In both cases, warning&#10; messages or error messages will be issued to the host to be displayed or otherwise&#10; handled as the host sees fit.&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;First, there might be queued messages that were received on &lt;code&gt;toSend&lt;/code&gt; but have not yet&#10;been sent, either because the socket has not yet been opened or because&#10;it was closed from the other side.&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;Second, a message might be received from the server after shutdown has commenced.&#10;In particular, received messages are handled asynchronously by a handler function&#10;that can be invoked at any time, and that handler might be invoked after it is no&#10;longer possible for this accessor to produce outputs (it has entered its wrapup&#10;phase of execution).&lt;/p&gt;&#10;&lt;p&gt;The client might similarly lose messages by the same two mechanisms occurring&#10;on the client side. In that case, messages will presumably be displayed on the&#10;client side.&lt;/p&gt;&#10;&lt;p&gt;Accessors that extend this one can override the &lt;code&gt;toSendInputHandler&lt;/code&gt; function&#10;to customize what is sent. &lt;/p&gt;&#10;&lt;p&gt;This accessor requires the 'socket' module.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee, Hokeun Kim">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="clientAuth (parameter)" class="ptolemy.kernel.util.StringAttribute" value="One of 'none', 'request', or 'required', meaning&#10;   whether it requires that a certificate be presented.">
            </property>
            <property name="hostInterface (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The name of the network interface to use for&#10;   listening, e.g. 'localhost'. The default is '0.0.0.0', which means to&#10;   listen on all available interfaces.">
            </property>
            <property name="receiveType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See below.">
            </property>
            <property name="sendType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See below.">
            </property>
            <property name="idleTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The amount of idle time in seconds that will cause&#10;   a disconnection of a socket. This defaults to 0, which means no&#10;   timeout.">
            </property>
            <property name="keepAlive (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether to keep a connection alive and reuse it. This&#10;   defaults to true.">
            </property>
            <property name="noDelay (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, data as sent as soon as it is available&#10;   (the default). If false, data may be accumulated until a reasonable packet size is&#10;   formed in order to make more efficient use of the network (using Nagle's algorithm).">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The default port to listen on. This defaults to 4000.&#10;   a value of 0 means to choose a random ephemeral free port.">
            </property>
            <property name="rawBytes (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true (the default), then transmit only the data bytes provided&#10;   to this.send() without any header. If false, then prepend sent data with length&#10;   information and assume receive data starts with length information.&#10;   Setting this false on both ends will ensure that each data item passed to&#10;   this.send() is emitted once in its entirety at the receiving end, as a single&#10;   message. When this is false, the receiving end can emit a partially received&#10;   message or could concatenate two messages and emit them together.">
            </property>
            <property name="receiveBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="sendBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="sslTls (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether SSL/TLS is enabled. This defaults to false.">
            </property>
            <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" value="The data to be sent over the socket.">
            </property>
            <property name="listening (port)" class="ptolemy.kernel.util.StringAttribute" value="When the server is listening for connections, this output&#10;   will produce the port number that the server is listening on&#10;   (this is useful if the port is specified to be 0).">
            </property>
            <property name="connection (port)" class="ptolemy.kernel.util.StringAttribute" value="Output an object with the properties specified above when a&#10;    connection is established.">
            </property>
            <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" value="The data received from the web socket server.">
            </property>
            <property name="receivedID (port)" class="ptolemy.kernel.util.StringAttribute" value="The ID of the connection over which data produced on the received&#10;   output was received. This is a positive integer, as indicated in the connection&#10;   output.">
            </property>
            <property name="toSendID (port)" class="ptolemy.kernel.util.StringAttribute" value="The ID of the connection over which to send the data, where 0 means&#10;   to send to all open connections.">
            </property>
            <property name="discardSendToUnopenedSocket (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, then discard any data&#10;  sent to a socket that is not open. The data will be logged using console.log()&#10;  instead. This defaults to false.">
            </property>
            <property name="pfxKeyCertPassword (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true, then this option&#10;   needs to specify the password for the pfx key-cert file specified by pfxKeyCertPath.">
            </property>
            <property name="pfxKeyCertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true, then this option&#10;   needs to specify the fully qualified filename for the file that stores the&#10;   private key and certificate that this server will use to identify itself. This path can be&#10;   any of those understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.">
            </property>
            <property name="trustedCACertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and this server&#10;   requests/requires a certificate from the client, then this option needs to specify&#10;   the filename for the file that stores the certificate of a certificate authority (CA) that&#10;   this server will use to verify client certificates. This path can be any of those&#10;   understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10;   FIXME: Need to be a list of paths for certificates rather than a single path.">
            </property>
        </property>
        <property name="pfxKeyCertPassword" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="pfxKeyCertPath" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="trustedCACertPath" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="toSendID" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
        </port>
        <port name="listening" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="connection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="receivedID" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="MicrostepDelay" class="ptolemy.actor.lib.MicrostepDelay">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-120.0, 150.0]">
        </property>
        <property name="_flipPortsHorizontal" class="ptolemy.data.expr.Parameter" value="true">
        </property>
    </entity>
    <entity name="Test" class="ptolemy.actor.lib.Test">
        <property name="correctValues" class="ptolemy.data.expr.Parameter" value="{{{1.1, 1.2}}}">
        </property>
        <property name="trainingMode" class="ptolemy.actor.parameters.SharedParameter" value="false">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[70.0, 210.0]">
        </property>
    </entity>
    <entity name="Test2" class="ptolemy.actor.lib.Test">
        <property name="correctValues" class="ptolemy.data.expr.Parameter" value="{{{1.1, 1.2}}}">
        </property>
        <property name="trainingMode" class="ptolemy.actor.parameters.SharedParameter" value="false">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[460.0, 120.0]">
        </property>
    </entity>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[85.0, 50.0]">
        </vertex>
    </relation>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[5.0, 150.0]">
        </vertex>
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[400.0, 40.0]">
        </vertex>
    </relation>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="ServerReceived.input" relation="relation4"/>
    <link port="Const.output" relation="relation6"/>
    <link port="Const.trigger" relation="relation7"/>
    <link port="ClientReceived.input" relation="relation5"/>
    <link port="TCPSocketClient.toSend" relation="relation6"/>
    <link port="TCPSocketClient.received" relation="relation5"/>
    <link port="TCPSocketClient.port" relation="relation"/>
    <link port="TCPSocketServer.toSend" relation="relation2"/>
    <link port="TCPSocketServer.listening" relation="relation"/>
    <link port="TCPSocketServer.connection" relation="relation7"/>
    <link port="TCPSocketServer.received" relation="relation4"/>
    <link port="MicrostepDelay.input" relation="relation4"/>
    <link port="MicrostepDelay.output" relation="relation2"/>
    <link port="Test.input" relation="relation4"/>
    <link port="Test2.input" relation="relation5"/>
</entity>
